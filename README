Loom, a plugin for bzr to assist in developing focused patches.
Copyright (C) 2006 Canonical Limited.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA


Loom is a bzr plugin which extends bzr with features to manage a loom of patches.


Loom is similar in concept to the tools 'quilt', 'stacked git' and 'mercurial
queues'. Its most significant difference is the ability to collaborate on the
stack of patches, without needing to do conflict resolution, and managing of
the list of patches via diff hunks. Instead you are able to develop the stack
using the full power of a version control system - you can rollback, annotate,
and push and pull the stack that is being built. We call the tool Loom because
unlike the three tools mentioned above there are two dimensions to the loom:
 - The up and down dimension, which is precisely equivalent to the quilt/
   stacked git/ mercurial queues stack of patches, which you can go up and 
   down in.
 - The time dimension, where we record the stack of patches as it alters over
   time. It is this new dimension that allows us to push, pull and merge the
   loom between users, much like adding a time dimension to a normal source
   tree allows easier sharing between developers.


Loom adds the following new commands:
 * loomify: This converts a branch into a loom enabled branch. As a result
   of this, the branch format is converted and you need to have the loom
   plugin installed to use it after that. The current branch nickname becomes
   the base thread in the loom.

 * create-thread: This adds a new thread to the loom with the supplied name
   and positions the branch on the new thread.

 * record: Perform a commit of the loom - record the current stack of patches
   into history, allowing it to be pushed, pulled and merged.

 * revert-loom: Revert all change in the current stack of patches to the last
   recorded one.

 * show-loom: Shows the threads in the loom. It currently does not show the
   # of commits in each thread, but it is planned to do that in the future.

 * down-thread: Move the branch down a thread. After doing this commits and 
   merges in this branch will affect the newly selected thread.

 * up-thread: Move the branch up a thread. This will merge in all the changes
   from the current thread that are not yet integrated into the new thread into
   it and leave you ready to commit them.

 * combine-thread: Combine the current thread with the thread below it. If
   It is the last thread, this will currently refuse to operate, but in the
   future will just turn the loom into a normal branch again. Use this command
   to remove a thread which has been merged into upstream. 

The existing bzr commands 'push' and 'branch' will create a loom branch from
existing looms. A push into an existing non-loom will not convert it however:
it will push the current thread into that branch. likewise pull from a normal
branch will pull into the current thread. This assymetry is a feature because
it allows easy interoperation with developers not using looms.


Loom also adds a new revision specifier 'thread:'. You can use this to diff
against threads in the current Loom. For instance, 'bzr diff -r thread:' will
show you the different between the thread below yours, and your thread.


Internals
=========

XXX: In development

Why we dont use the revision_id to index into the loom:
# XXX: possibly we should use revision_id to determine what the
# loom looked like when it was committed, rather than taking a
# revision id in the loom branch. This suggests recording the 
# loom revision when writing a commit to a warp, which would mean
# that commit() could not do record() - we would have to record 
# a loom revision that was not yet created.
